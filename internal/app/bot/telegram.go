//go:generate mockery --case underscore --name PhotographerServiceClient --with-expecter
//go:generate mockery --case underscore --name RegistratorServiceClient --with-expecter
//go:generate mockery --case underscore --name RequestsFacade --with-expecter
//go:generate mockery --case underscore --name TelegramBot --with-expecter

package bot

import (
	"context"
	"fmt"
	"runtime/debug"

	"github.com/google/uuid"
	"github.com/nikita5637/quiz-registrator-api/pkg/pb/registrator"
	"github.com/nikita5637/quiz-telegram/internal/pkg/logger"
	"github.com/nikita5637/quiz-telegram/internal/pkg/model"
	telegrampb "github.com/nikita5637/quiz-telegram/pkg/pb/telegram"
	uuid_utils "github.com/nikita5637/quiz-telegram/utils/uuid"
	"google.golang.org/genproto/googleapis/rpc/errdetails"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// CroupierServiceClient ...
type CroupierServiceClient interface {
	registrator.CroupierServiceClient
}

// PhotographerServiceClient ...
type PhotographerServiceClient interface {
	registrator.PhotographerServiceClient
}

// RegistratorServiceClient ...
type RegistratorServiceClient interface {
	registrator.RegistratorServiceClient
}

// RequestsFacade ...
type RequestsFacade interface {
	GetRequest(ctx context.Context, uuid string) ([]byte, error)
	// Returns UUID generated by database
	RegisterRequest(ctx context.Context, request model.Request) (string, error)
	UnregisterRequest(ctx context.Context, uuid string) error
}

// TelegramBot ...
type TelegramBot interface { // nolint:revive
	GetUpdatesChan(config tgbotapi.UpdateConfig) tgbotapi.UpdatesChannel
	Request(c tgbotapi.Chattable) (*tgbotapi.APIResponse, error)
	Send(c tgbotapi.Chattable) (tgbotapi.Message, error)
	StopReceivingUpdates()
}

// Bot ...
type Bot struct {
	bot TelegramBot // *tgbotapi.BotAPI

	registratorAPIAddress string
	registratorAPIPort    uint16

	requestsFacade RequestsFacade

	croupierServiceClient     CroupierServiceClient
	photographerServiceClient PhotographerServiceClient
	registratorServiceClient  RegistratorServiceClient

	telegrampb.UnimplementedMessageSenderServiceServer
}

// Config ...
type Config struct {
	Bot TelegramBot // *tgbotapi.BotAPI

	RequestsFacade RequestsFacade

	RegistratorAPIAddress string
	RegistratorAPIPort    uint16
}

// New ...
func New(cfg Config) (*Bot, error) {
	bot := &Bot{
		bot: cfg.Bot,

		requestsFacade: cfg.RequestsFacade,

		registratorAPIAddress: cfg.RegistratorAPIAddress,
		registratorAPIPort:    cfg.RegistratorAPIPort,
	}
	return bot, nil
}

// Start ...
func (b *Bot) Start(ctx context.Context) error {
	opts := grpc.WithInsecure()
	target := fmt.Sprintf("%s:%d", b.registratorAPIAddress, b.registratorAPIPort)
	cc, err := grpc.Dial(target, opts, grpc.WithChainUnaryInterceptor(
		logInterceptor,
		telegramInterceptor,
	))
	if err != nil {
		return fmt.Errorf("could not connect: %w", err)
	}

	b.croupierServiceClient = registrator.NewCroupierServiceClient(cc)
	b.photographerServiceClient = registrator.NewPhotographerServiceClient(cc)
	b.registratorServiceClient = registrator.NewRegistratorServiceClient(cc)

	u := tgbotapi.NewUpdate(0)
	u.Timeout = 60

	updates := b.bot.GetUpdatesChan(u)

	go func(ctx context.Context) {
		for update := range updates {
			go func(ctx context.Context, update tgbotapi.Update) {
				defer func() {
					if r := recover(); r != nil {
						logger.ErrorKV(ctx, "panic recovered", "r", r, "update", update, "stack", string(debug.Stack()))
					}
				}()

				if update.CallbackQuery == nil && update.Message == nil && update.InlineQuery == nil {
					return
				}

				groupUUID := uuid.New().String()
				ctx = uuid_utils.NewContextWithGroupUUID(ctx, groupUUID)

				if update.CallbackQuery != nil && update.CallbackQuery.Message != nil {
					if err := b.HandleCallbackQuery(ctx, &update); err != nil {
						logger.Errorf(ctx, "callback query handle error: %s", err)
						clientID := update.CallbackQuery.From.ID
						responseMessage := tgbotapi.NewMessage(clientID, getTranslator(somethingWentWrongLexeme)(ctx))
						if s, ok := status.FromError(err); ok {
							if s.Code() == codes.PermissionDenied {
								responseMessage = tgbotapi.NewMessage(clientID, getTranslator(permissionDeniedLexeme)(ctx))
							}
							if s.Code() == codes.NotFound {
								for _, detail := range s.Details() {
									switch t := detail.(type) {
									case *errdetails.LocalizedMessage:
										responseMessage = tgbotapi.NewMessage(clientID, t.GetMessage())
									}
								}
							}
						}

						if _, err := b.bot.Send(responseMessage); err != nil {
							logger.Errorf(ctx, "error while send message: %s", err)
						}
					}
				} else if update.CallbackQuery != nil && update.CallbackQuery.InlineMessageID != "" {
					var err2 error
					err2 = b.HandleInlineMessage(ctx, &update)
					if err2 != nil {
						logger.Errorf(ctx, "inline message handle error: %s", err2)
					}
				} else if update.InlineQuery != nil {
					var err2 error
					err2 = b.HandleInlineQuery(ctx, &update)
					if err2 != nil {
						logger.Errorf(ctx, "inline query handle error: %s", err2)
					}
				} else if update.Message != nil {
					if err := b.HandleMessage(ctx, &update); err != nil {
						logger.Errorf(ctx, "handle message error: %s", err)
					}
				}
			}(ctx, update)
		}
	}(ctx)

	<-ctx.Done()

	b.bot.StopReceivingUpdates()
	cc.Close()

	logger.Info(ctx, "telegram bot gracefully stopped")
	return nil
}
